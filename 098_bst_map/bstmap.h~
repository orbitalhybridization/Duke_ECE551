#include <stdexcept>

#include "map.h"
template<typename K, typename V>
class BstMap : public Map<K, V> {
 private:
  class Node {
    K key;
    V value;
    Node * left;
    Node * right;

   public:
    Node() : key(0), value(0), left(NULL), right(NULL){};
    Node(K key_, V value_) : key(key_), value(value_), left(NULL), right(NULL){};
  };
  Node * root;

 public:
  virtual void add(const K & key, const V & value) { root = add(root, key, value); }

  Node * add(Node * current, const K & key, const V & value) {  // helper function
    if (current == NULL) {
      Node * ans = new Node(key, value);
      return ans;
    }
    else {
      if (key < current->key) {
        Node * newLeft = add(current->left, key, value);
        current->left = newLeft;
      }
      else {
        Node * newRight = add(current->right, key, value);
        current->right = newRight;
      }
      return current;
    }
  }

  virtual const V & lookup(const K & key) const throw(std::invalid_argument) {
    Node * current = root;
    while (current != NULL) {
      if (current->key == key) {
        return current->value;
      }
      else if (key < current->key) {
        current = current->left;
      }
      else {
        current = current->right;
      }
    }
    throw std::invalid_argument("not right");
  }

  virtual void remove(const K & key) {
    // go left once then all the way right
    Node ** to_delete = &root;
    // find thing to remove
    // keep track of parent or
    Node ** next;
    while (to_delete != NULL) {
      if (to_delete->key == key) {
        break;
      }
      else if (key < to_delete->key) {
        to_delete = to_delete->left;
      }
      else {
        to_delete = to_delete->right;
      }
    }
    Node * replace = root;
    Node * prev = NULL;
    while (replace->right != NULL) {
      replace = replace->right;
      prev = replace;
    }
    to_delete = replace;
    prev->right = replace->right;
    replace->right->left = delete replace;
  }

  Node * helperRemove(node) {}

  void clear(Node * node) {  // do a postorder traversal
    if (node != NULL) {
      clear(node->left);
      clear(node->right);
      delete node;
    }
  }
  virtual ~BstMap<K, V>() { clear(root); }
};
